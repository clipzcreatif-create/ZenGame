<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Voxel Fishing - Minecraft Style</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            background-color: #87CEEB;
            user-select: none;
            touch-action: none; /* Mencegah zoom/scroll di HP */
            -webkit-touch-callout: none;
        }

        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            text-shadow: 2px 2px 0 #000;
            pointer-events: none;
            z-index: 10;
        }

        h1 {
            margin: 0;
            font-size: 24px;
            color: #FFFF55;
        }

        #status {
            font-size: 18px;
            margin-top: 10px;
            font-weight: bold;
        }

        #controls-hint {
            font-size: 14px;
            color: #ddd;
            margin-top: 5px;
        }

        #inventory {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px;
            border: 3px solid #ddd;
            border-radius: 4px;
            color: white;
            font-family: 'Courier New', Courier, monospace;
            min-width: 180px;
            z-index: 10;
        }

        .inv-title {
            text-align: center;
            border-bottom: 2px solid #aaa;
            margin-bottom: 8px;
            padding-bottom: 5px;
            font-weight: bold;
            color: #FFFF55;
        }

        .item-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px;
            background: rgba(255, 255, 255, 0.1);
            padding: 4px;
            border-radius: 4px;
        }

        .item-icon {
            font-size: 20px;
            margin-right: 8px;
        }

        .item-name {
            flex-grow: 1;
            font-size: 14px;
        }

        .item-count {
            font-weight: bold;
            color: #FFFF55;
        }

        #instruction {
            position: absolute;
            bottom: 50px;
            width: 100%;
            text-align: center;
            color: white;
            font-size: 20px;
            text-shadow: 2px 2px 0 #000;
            animation: pulse 1.5s infinite;
            pointer-events: none;
            display: block;
            z-index: 5;
        }

        #minigame-container {
            position: absolute;
            bottom: 150px; /* Naikkan dikit biar gak ketutup tombol HP */
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 40px;
            background: #222;
            border: 4px solid white;
            display: none;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            border-radius: 8px;
            overflow: hidden;
            z-index: 20;
        }

        #minigame-bar {
            width: 50%;
            height: 100%;
            background: linear-gradient(90deg, #ff3333, #ffff33, #33ff33);
            transition: width 0.05s linear;
        }

        #minigame-target-line {
            position: absolute;
            right: 10%;
            top: 0;
            height: 100%;
            width: 4px;
            background: rgba(255, 255, 255, 0.5);
            z-index: 21;
        }

        #minigame-text {
            position: absolute;
            top: -35px;
            width: 100%;
            text-align: center;
            color: #FFFF55;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            font-size: 18px;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #222;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
            font-size: 24px;
        }

        /* --- MOBILE CONTROLS --- */
        .mobile-controls {
            display: none; /* Default hidden */
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 150px;
            pointer-events: none; /* Biar area kosong bisa ditap buat minigame */
            z-index: 50;
        }

        /* D-PAD */
        .dpad {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 120px;
            height: 120px;
            pointer-events: auto;
        }

        .dpad-btn {
            position: absolute;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 8px;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            color: white;
            user-select: none;
        }
        .dpad-btn:active { background: rgba(255, 255, 255, 0.6); }

        .d-up { top: 0; left: 40px; }
        .d-down { bottom: 0; left: 40px; }
        .d-left { top: 40px; left: 0; }
        .d-right { top: 40px; right: 0; }

        /* ACTION BUTTON */
        .action-btn-container {
            position: absolute;
            bottom: 30px;
            right: 30px;
            pointer-events: auto;
        }

        .action-btn {
            width: 80px;
            height: 80px;
            background: rgba(255, 50, 50, 0.5);
            border: 3px solid white;
            border-radius: 50%;
            color: white;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            text-align: center;
            box-shadow: 0 4px 0 #330000;
        }
        .action-btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 #330000;
            background: rgba(255, 50, 50, 0.8);
        }

        /* Show controls on mobile screens */
        @media (max-width: 800px) {
            .mobile-controls { display: block; }
            #controls-hint { display: none; } /* Hide PC hint on mobile */
        }
    </style>
</head>
<body>

    <div id="loading">Memuat Dunia Kotak...</div>

    <div id="ui-container">
        <h1>ðŸŽ£ Voxel Fishing</h1>
        <div id="controls-hint">[W,A,S,D] Jalan | [Klik Kanan] Lempar</div>
        <div id="status">Cari spot mancing...</div>
    </div>

    <!-- Inventory -->
    <div id="inventory">
        <div class="inv-title">TAS PANCING</div>
        <div id="inv-list">
            <div style="text-align:center; color:#aaa; font-size:12px;">(Kosong)</div>
        </div>
    </div>

    <div id="instruction"></div>

    <!-- UI Minigame Tarik Ikan -->
    <div id="minigame-container">
        <div id="minigame-text">TAP SPASI / KLIK !!!</div>
        <div id="minigame-target-line"></div>
        <div id="minigame-bar"></div>
    </div>

    <!-- MOBILE CONTROLS OVERLAY -->
    <div class="mobile-controls" id="mobile-ui">
        <div class="dpad">
            <div class="dpad-btn d-up" id="btn-up">â–²</div>
            <div class="dpad-btn d-down" id="btn-down">â–¼</div>
            <div class="dpad-btn d-left" id="btn-left">â—€</div>
            <div class="dpad-btn d-right" id="btn-right">â–¶</div>
        </div>
        <div class="action-btn-container">
            <div class="action-btn" id="btn-action">MANCING</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- KONFIGURASI DAN VARIABEL GLOBAL ---
        let scene, camera, renderer;
        let waterBlocks = [];
        let bobber, fishingLine, rodTip;
        let particles = [];
        let playerGroup; // Grup mesh player
        
        // Input Movement
        const keysPressed = {};
        const playerSpeed = 0.15;
        
        // State Game: IDLE, CASTING, WAITING, BITING, FIGHTING, REELING
        let gameState = "IDLE"; 
        let biteTimer = 0;
        
        // Minigame Variables
        let fightProgress = 30; // 0 - 100
        let fightDecayRate = 0.5; // Seberapa cepat ikan kabur
        
        // Inventaris (Object untuk menyimpan jumlah item)
        const inventory = {};
        const SAVE_KEY = "voxelFishing_save_v1"; // Kunci penyimpanan
        
        // Loot Table dengan ICON
        const lootTable = [
            { name: "Ikan Mentah", chance: 50, color: "#e6c385", difficulty: 0.5, icon: "ðŸŸ" }, 
            { name: "Salmon", chance: 30, color: "#ff7575", difficulty: 0.7, icon: "ðŸ " },
            { name: "Ikan Buntal", chance: 10, color: "#ffff55", difficulty: 0.9, icon: "ðŸ¡" },
            { name: "Sampah", chance: 8, color: "#444", difficulty: 0.4, icon: "ðŸ‘¢" },
            { name: "Diamond", chance: 2, color: "#00ffff", difficulty: 1.3, icon: "ðŸ’Ž" } 
        ];

        let currentTargetLoot = null; // Loot yang sedang ditarik

        // --- INISIALISASI ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); 
            scene.fog = new THREE.Fog(0x87CEEB, 20, 60);

            const aspect = window.innerWidth / window.innerHeight;
            const d = 15;
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
            
            camera.position.set(20, 20, 20); 
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: false }); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            scene.add(dirLight);

            createWorld();
            createPlayer();

            // Mobile Detection Logic (Force show if touch device)
            if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
                document.getElementById('mobile-ui').style.display = 'block';
                document.getElementById('controls-hint').style.display = 'none';
            }

            window.addEventListener('resize', onWindowResize, false);
            
            // Mouse & Keyboard Input
            document.addEventListener('contextmenu', event => event.preventDefault()); 
            document.addEventListener('mousedown', handleMouseInput);
            document.addEventListener('keydown', (e) => {
                keysPressed[e.code] = true;
                if(e.code === 'Space') handleActionInput(); 
            });
            document.addEventListener('keyup', (e) => {
                keysPressed[e.code] = false;
            });

            // Touch Controls Setup
            setupTouchControls();

            document.getElementById('loading').style.display = 'none';
            
            // LOAD GAME SAAT MULAI
            loadGame();

            animate();
        }

        function setupTouchControls() {
            const btnUp = document.getElementById('btn-up');
            const btnDown = document.getElementById('btn-down');
            const btnLeft = document.getElementById('btn-left');
            const btnRight = document.getElementById('btn-right');
            const btnAction = document.getElementById('btn-action');

            // Helper for touch events
            const addTouchHandler = (elem, keyCode) => {
                elem.addEventListener('touchstart', (e) => { e.preventDefault(); keysPressed[keyCode] = true; });
                elem.addEventListener('touchend', (e) => { e.preventDefault(); keysPressed[keyCode] = false; });
            };

            addTouchHandler(btnUp, 'KeyW');
            addTouchHandler(btnDown, 'KeyS');
            addTouchHandler(btnLeft, 'KeyA');
            addTouchHandler(btnRight, 'KeyD');

            // Action Button (Simulates Right Click behavior)
            btnAction.addEventListener('touchstart', (e) => {
                e.preventDefault();
                // Jika sedang fighting, tombol ini juga bisa dipakai buat nge-tap
                if (gameState === "FIGHTING") {
                    handleActionInput();
                    // Efek visual tombol ditekan
                    btnAction.style.transform = "translateY(4px)";
                } else {
                    // Logic lempar/tarik
                    performPrimaryAction();
                }
            });

            btnAction.addEventListener('touchend', (e) => {
                e.preventDefault();
                btnAction.style.transform = "translateY(0px)";
            });
        }

        // --- INPUT HANDLING ---

        function handleMouseInput(e) {
            // Klik Kanan (Button 2) untuk Melempar/Action Utama
            if (e.button === 2) { 
                performPrimaryAction();
            } 
            // Klik Kiri (Button 0) untuk Minigame Tap-Tap
            else if (e.button === 0) {
                handleActionInput();
            }
        }

        // Fungsi Utama Aksi (Bisa dari Klik Kanan atau Tombol HP)
        function performPrimaryAction() {
            if (gameState === "IDLE") {
                startCasting();
            } else if (gameState === "WAITING") {
                resetFishing("Ditarik terlalu cepat!");
            } else if (gameState === "BITING") {
                startFighting(); 
            }
        }

        function handleActionInput() {
            if (gameState === "FIGHTING") {
                // Logic Tap-Tap
                fightProgress += 10; 
                
                // Efek visual pancingan bergerak
                if(playerGroup) {
                    playerGroup.rotation.z = (Math.random() - 0.5) * 0.3; 
                }

                if (fightProgress >= 100) {
                    fightProgress = 100;
                    winFishing();
                }
            }
        }

        // --- LOGIKA GAMEPLAY ---

        function startCasting() {
            gameState = "CASTING";
            document.getElementById('status').innerText = "Melempar...";
            document.getElementById('instruction').innerText = "";
            
            // Update Text Button HP
            document.getElementById('btn-action').innerText = "...";

            castBobber();
        }

        function castBobber() {
            if (bobber) scene.remove(bobber);

            const bobberGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            const bobberMat = new THREE.MeshLambertMaterial({ color: 0xFF0000 });
            bobber = new THREE.Mesh(bobberGeo, bobberMat);
            
            const tipPos = new THREE.Vector3();
            rodTip.getWorldPosition(tipPos);
            bobber.position.copy(tipPos);
            scene.add(bobber);

            let t = 0;
            const start = tipPos.clone();
            
            const target = new THREE.Vector3(
                (Math.random() - 0.5) * 6, 
                0, 
                (Math.random() - 0.5) * 6
            );

            const animateCast = setInterval(() => {
                t += 0.05;
                if (t >= 1) {
                    clearInterval(animateCast);
                    gameState = "WAITING";
                    document.getElementById('status').innerText = "Menunggu...";
                    document.getElementById('instruction').innerText = "Tunggu pelampung bergerak...";
                    document.getElementById('btn-action').innerText = "TUNGGU";
                    document.getElementById('btn-action').style.background = "#555";
                    bobber.position.y = 0; 
                    startFishLogic();
                } else {
                    bobber.position.x = start.x + (target.x - start.x) * t;
                    bobber.position.z = start.z + (target.z - start.z) * t;
                    const height = 5;
                    bobber.position.y = start.y + (target.y - start.y) * t + height * (Math.sin(t * Math.PI));
                }
            }, 16);
        }

        function startFishLogic() {
            const waitTime = Math.random() * 3000 + 1500;
            setTimeout(() => {
                if (gameState === "WAITING") {
                    triggerBite();
                }
            }, waitTime);
        }

        function triggerBite() {
            gameState = "BITING";
            document.getElementById('status').innerText = "!!! KLIK / TAP !!!";
            document.getElementById('status').style.color = "red";
            
            // Update Mobile Button
            const btn = document.getElementById('btn-action');
            btn.innerText = "TARIK!";
            btn.style.background = "red";

            createSplash(bobber.position);
            currentTargetLoot = getLoot();

            biteTimer = setTimeout(() => {
                if (gameState === "BITING") {
                    resetFishing("Ikan Lepas...");
                }
            }, 1500); 
        }

        function startFighting() {
            clearTimeout(biteTimer);
            gameState = "FIGHTING";
            document.getElementById('status').innerText = "TAP TAP TERUS!";
            document.getElementById('status').style.color = "yellow";
            
            // Update Mobile Button
            const btn = document.getElementById('btn-action');
            btn.innerText = "TAP!!";
            btn.style.background = "orange";
            
            fightProgress = 30; 
            document.getElementById('minigame-container').style.display = 'block';
            
            fightDecayRate = 0.5 + (currentTargetLoot.difficulty * 0.4);
        }

        function updateFightingMinigame() {
            if (gameState !== "FIGHTING") return;

            fightProgress -= fightDecayRate;

            const bar = document.getElementById('minigame-bar');
            let visualProgress = Math.max(0, Math.min(100, fightProgress));
            bar.style.width = visualProgress + "%";
            
            if (fightProgress < 30) bar.style.background = "#ff3333";
            else if (fightProgress > 70) bar.style.background = "#33ff33";
            else bar.style.background = "#ffff33";

            if (fightProgress >= 100) {
                winFishing();
            }
            else if (fightProgress <= 0) {
                resetFishing("Tali Putus! Ikan terlalu kuat.");
            }

            if(bobber) {
                bobber.position.x += (Math.random()-0.5) * 0.15;
                bobber.position.z += (Math.random()-0.5) * 0.15;
                createSplash(bobber.position);
            }
        }

        function winFishing() {
            if (gameState === "REELING") return;
            
            gameState = "REELING";
            document.getElementById('minigame-container').style.display = 'none';
            document.getElementById('status').innerText = "Dapat!";
            document.getElementById('status').style.color = "white";
            document.getElementById('btn-action').style.display = "none"; // Hide button saat animasi
            
            if(playerGroup) playerGroup.rotation.z = 0;

            reelInAnimation();
        }

        function reelInAnimation() {
            let t = 0;
            const start = bobber.position.clone();
            const tipPos = new THREE.Vector3();
            rodTip.getWorldPosition(tipPos);

            const itemGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
            const itemMat = new THREE.MeshLambertMaterial({ color: currentTargetLoot.color });
            const caughtItem = new THREE.Mesh(itemGeo, itemMat);
            caughtItem.position.copy(start);
            scene.add(caughtItem);
            scene.remove(bobber); 
            bobber = null;

            const animateReel = setInterval(() => {
                t += 0.05;
                if (t >= 1) {
                    clearInterval(animateReel);
                    scene.remove(caughtItem);
                    
                    addToInventory(currentTargetLoot);
                    
                    gameState = "IDLE"; 
                    document.getElementById('status').innerText = `Dapat: ${currentTargetLoot.name}!`;
                    document.getElementById('instruction').innerText = "";
                    
                    // Reset Button UI
                    const btn = document.getElementById('btn-action');
                    btn.style.display = "flex";
                    btn.innerText = "MANCING";
                    btn.style.background = "rgba(255, 50, 50, 0.5)";

                } else {
                    caughtItem.position.lerp(tipPos, 0.1);
                    caughtItem.rotation.y += 0.3;
                    caughtItem.rotation.x += 0.3;
                }
            }, 16);
        }

        function getLoot() {
            const rand = Math.random() * 100;
            let currentChance = 0;
            for (let item of lootTable) {
                currentChance += item.chance;
                if (rand <= currentChance) return item;
            }
            return lootTable[0];
        }

        function resetFishing(msg) {
            if (bobber) {
                scene.remove(bobber);
                bobber = null;
            }
            gameState = "IDLE";
            document.getElementById('minigame-container').style.display = 'none';
            document.getElementById('status').innerText = msg;
            document.getElementById('status').style.color = "white";
            
            // Reset Button UI
            const btn = document.getElementById('btn-action');
            btn.style.display = "flex";
            btn.innerText = "MANCING";
            btn.style.background = "rgba(255, 50, 50, 0.5)";

            if(playerGroup) playerGroup.rotation.z = 0;
        }

        function addToInventory(item) {
            if (!inventory[item.name]) {
                inventory[item.name] = { count: 0, data: item };
            }
            inventory[item.name].count++;
            
            // AUTO SAVE SETIAP DAPAT ITEM
            saveGame();
            updateInventoryUI();
            
            if(item.name === "Diamond") {
                createExplosion(playerGroup.position, 0x00ffff);
            }
        }

        // --- SAVE SYSTEM ---
        function saveGame() {
            try {
                localStorage.setItem(SAVE_KEY, JSON.stringify(inventory));
                
                // Efek visual 'Menyimpan...' di judul inventory
                const title = document.querySelector('.inv-title');
                if(title.innerText !== "MENYIMPAN...") {
                    const originalText = "TAS PANCING";
                    title.innerText = "MENYIMPAN...";
                    title.style.color = "#55ff55"; // Hijau
                    
                    setTimeout(() => {
                        title.innerText = originalText;
                        title.style.color = "#FFFF55"; // Kembali Kuning
                    }, 800);
                }
            } catch (e) {
                console.error("Gagal menyimpan:", e);
            }
        }

        function loadGame() {
            try {
                const data = localStorage.getItem(SAVE_KEY);
                if (data) {
                    const parsed = JSON.parse(data);
                    // Isi inventory dengan data yang disimpan
                    Object.assign(inventory, parsed);
                    updateInventoryUI();
                    console.log("Game berhasil dimuat!");
                }
            } catch (e) {
                console.error("Gagal memuat save:", e);
            }
        }

        function updateInventoryUI() {
            const list = document.getElementById('inv-list');
            list.innerHTML = "";
            
            let hasItem = false;
            for (const [key, value] of Object.entries(inventory)) {
                if (value.count > 0) {
                    hasItem = true;
                    list.innerHTML += `
                        <div class="item-row">
                            <span class="item-icon">${value.data.icon}</span> 
                            <span class="item-name">${key}</span>
                            <span class="item-count">x${value.count}</span>
                        </div>`;
                }
            }
            
            if (!hasItem) {
                list.innerHTML = `<div style="text-align:center; color:#aaa; font-size:12px;">(Kosong)</div>`;
            }
        }

        // --- CREATION FUNCTIONS ---

        function createWorld() {
            const blockSize = 2;
            const mapSize = 16; 
            
            const geometryBox = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
            const grassMat = new THREE.MeshLambertMaterial({ color: 0x55aa55 }); 
            const dirtMat = new THREE.MeshLambertMaterial({ color: 0x885533 });  
            const waterMat = new THREE.MeshLambertMaterial({ color: 0x4444ff, transparent: true, opacity: 0.8 }); 

            for (let x = -mapSize/2; x < mapSize/2; x++) {
                for (let z = -mapSize/2; z < mapSize/2; z++) {
                    let isWater = false;
                    if (Math.abs(x) < 3 && Math.abs(z) < 3) isWater = true;

                    if (isWater) {
                        const water = new THREE.Mesh(geometryBox, waterMat);
                        water.position.set(x * blockSize, -1, z * blockSize);
                        water.userData = { originalY: -1 };
                        scene.add(water);
                        waterBlocks.push(water);

                        const sand = new THREE.Mesh(geometryBox, dirtMat);
                        sand.position.set(x * blockSize, -1 - blockSize, z * blockSize);
                        scene.add(sand);
                    } else {
                        const grass = new THREE.Mesh(geometryBox, grassMat);
                        grass.position.set(x * blockSize, 0, z * blockSize);
                        grass.castShadow = true;
                        grass.receiveShadow = true;
                        scene.add(grass);

                        const dirt = new THREE.Mesh(geometryBox, dirtMat);
                        dirt.position.set(x * blockSize, -blockSize, z * blockSize);
                        scene.add(dirt);
                    }
                }
            }
            createTree(-10, -10);
            createTree(10, -8);
            createTree(-8, 10);
            createTree(12, 12);
        }

        function createTree(x, z) {
            const trunkGeo = new THREE.BoxGeometry(1, 6, 1);
            const trunkMat = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.set(x, 3, z);
            trunk.castShadow = true;
            scene.add(trunk);

            const leafGeo = new THREE.BoxGeometry(5, 5, 5);
            const leafMat = new THREE.MeshLambertMaterial({ color: 0x338833 });
            const leaf = new THREE.Mesh(leafGeo, leafMat);
            leaf.position.set(x, 7, z);
            leaf.castShadow = true;
            scene.add(leaf);
        }

        function createPlayer() {
            playerGroup = new THREE.Group();
            
            const bodyGeo = new THREE.BoxGeometry(1.5, 3, 1);
            const bodyMat = new THREE.MeshLambertMaterial({ color: 0x0000AA }); 
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 1.5;
            playerGroup.add(body);

            const headGeo = new THREE.BoxGeometry(1, 1, 1);
            const headMat = new THREE.MeshLambertMaterial({ color: 0xffccaa }); 
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 3.5;
            playerGroup.add(head);

            const armGeo = new THREE.BoxGeometry(0.5, 2, 0.5);
            const arm = new THREE.Mesh(armGeo, bodyMat);
            arm.position.set(1, 2, 0.5);
            arm.rotation.x = -Math.PI / 4; 
            playerGroup.add(arm);

            const rodGeo = new THREE.CylinderGeometry(0.05, 0.1, 6, 8);
            const rodMat = new THREE.MeshLambertMaterial({ color: 0x5c4033 });
            const rod = new THREE.Mesh(rodGeo, rodMat);
            rod.rotation.x = Math.PI / 2; 
            rod.rotation.z = -Math.PI / 8; 
            rod.position.set(1, 4, 2);
            playerGroup.add(rod);

            rodTip = new THREE.Object3D();
            rodTip.position.set(0, 3, 0); 
            rod.add(rodTip);

            playerGroup.position.set(0, 1, 8); 
            playerGroup.rotation.y = Math.PI; 
            scene.add(playerGroup);

            const lineMat = new THREE.LineBasicMaterial({ color: 0x000000 });
            const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,0)]);
            fishingLine = new THREE.Line(lineGeo, lineMat);
            scene.add(fishingLine);
        }

        function createSplash(pos) {
            for(let i=0; i<8; i++) {
                const size = Math.random() * 0.2 + 0.1;
                const geo = new THREE.BoxGeometry(size, size, size);
                const mat = new THREE.MeshBasicMaterial({ color: 0xeeeeff });
                const part = new THREE.Mesh(geo, mat);
                part.position.copy(pos);
                part.position.y = 0;
                part.userData = {
                    vel: new THREE.Vector3((Math.random()-0.5)*0.2, Math.random()*0.3, (Math.random()-0.5)*0.2)
                };
                scene.add(part);
                particles.push(part);
            }
        }

        function createExplosion(pos, color) {
            for(let i=0; i<20; i++) {
                const size = Math.random() * 0.3 + 0.2;
                const geo = new THREE.BoxGeometry(size, size, size);
                const mat = new THREE.MeshBasicMaterial({ color: color });
                const part = new THREE.Mesh(geo, mat);
                part.position.copy(pos);
                part.userData = {
                    vel: new THREE.Vector3((Math.random()-0.5)*0.5, Math.random()*0.5, (Math.random()-0.5)*0.5)
                };
                scene.add(part);
                particles.push(part);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;

            // --- MOVEMENT LOGIC ---
            if (playerGroup && gameState === "IDLE") { 
                const oldPos = playerGroup.position.clone();
                let moved = false;
                
                if (keysPressed['KeyW']) { playerGroup.position.z -= playerSpeed; playerGroup.rotation.y = Math.PI; moved = true; }
                if (keysPressed['KeyS']) { playerGroup.position.z += playerSpeed; playerGroup.rotation.y = 0; moved = true; }
                if (keysPressed['KeyA']) { playerGroup.position.x -= playerSpeed; playerGroup.rotation.y = -Math.PI/2; moved = true; }
                if (keysPressed['KeyD']) { playerGroup.position.x += playerSpeed; playerGroup.rotation.y = Math.PI/2; moved = true; }
                
                if (keysPressed['KeyW'] && keysPressed['KeyA']) playerGroup.rotation.y = -Math.PI * 0.75;
                if (keysPressed['KeyW'] && keysPressed['KeyD']) playerGroup.rotation.y = Math.PI * 0.75;
                if (keysPressed['KeyS'] && keysPressed['KeyA']) playerGroup.rotation.y = -Math.PI * 0.25;
                if (keysPressed['KeyS'] && keysPressed['KeyD']) playerGroup.rotation.y = Math.PI * 0.25;

                const absX = Math.abs(playerGroup.position.x);
                const absZ = Math.abs(playerGroup.position.z);

                if ((absX < 5 && absZ < 5)) {
                   playerGroup.position.copy(oldPos);
                }
                if (absX > 14 || absZ > 14) {
                    playerGroup.position.copy(oldPos);
                }

                const targetCamX = playerGroup.position.x + 20;
                const targetCamZ = playerGroup.position.z + 20;
                camera.position.x += (targetCamX - camera.position.x) * 0.1;
                camera.position.z += (targetCamZ - camera.position.z) * 0.1;
            }

            // Minigame Update
            if (gameState === "FIGHTING") {
                updateFightingMinigame();
            }

            // Water Animation
            waterBlocks.forEach((block, idx) => {
                block.position.y = block.userData.originalY + Math.sin(time * 2 + idx) * 0.05;
            });

            // Bobber Animation
            if (gameState === "WAITING" && bobber) {
                bobber.position.y = Math.sin(time * 5) * 0.1 - 0.2;
                if (gameState === "BITING") {
                    bobber.position.y = -0.5 + Math.sin(time * 20) * 0.2; 
                }
            }

            // Fishing Line Update
            if (fishingLine && rodTip && playerGroup) {
                const tipPos = new THREE.Vector3();
                rodTip.getWorldPosition(tipPos);
                const positions = fishingLine.geometry.attributes.position.array;
                positions[0] = tipPos.x; positions[1] = tipPos.y; positions[2] = tipPos.z;

                if (bobber) {
                    positions[3] = bobber.position.x; positions[4] = bobber.position.y; positions[5] = bobber.position.z;
                } else {
                    positions[3] = tipPos.x; positions[4] = tipPos.y; positions[5] = tipPos.z;
                }
                fishingLine.geometry.attributes.position.needsUpdate = true;
            }

            // Particles Update
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.userData.vel);
                p.userData.vel.y -= 0.01; 
                p.rotation.x += 0.1;
                if (p.position.y < -2) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const d = 15;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>
